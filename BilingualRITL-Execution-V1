(clear-all)

#+(or :clisp :sbcl :openmcl) (setf (logical-pathname-translations "INST")
				   `(("**;*.*" ,(namestring (merge-pathnames "**/*.*" *load-truename*)))))

(define-model execution

(chunk-type arithmetic-fact operation arg1 arg2 result)
(chunk-type ritl-stimulus x y)
(chunk-type ritl-instructions kind first second third)
(chunk-type operation argument1 operator argument2 trial type position)
(chunk-type scratchpad x y result position task)
(chunk-type do-execution step)

(load (translate-logical-pathname "INST:inst-arithmetic-facts.lisp"))

(add-dm (stimulus isa ritl-stimulus 
x 5 
y 6))

;;; Instructions in memory
(add-dm (double-1 isa operation argument1 x operator * argument2 2 type unary))
(add-dm (half-1 isa operation argument1 x operator / argument2 2 type unary))
(add-dm (add-1 isa operation argument1 x operator + argument2 y type binary))
(add-dm (inst isa ritl-instructions kind ritl-instructions first double-1 second half-1 third add-1))
;;; Operations

(set-buffer-chunk 'visual 'stimulus)

(p prepare
  ?goal>
    state free
    buffer empty
  
  =visual>
    isa      ritl-stimulus
    x       =X
    y       =y

==>
  =visual>
  +goal>
    isa do-execution
    step setup

  +retrieval>
    isa ritl-instructions
    kind ritl-instructions

)

(p calculate-x

 =goal>
    isa do-execution
    step setup

  ?imaginal>
    state free
    buffer empty

  =visual>
    isa  ritl-stimulus
    x    =x
    y    =y

  =retrieval>
    isa    ritl-instructions
    first   =task1

==>
  =visual>
  =retrieval>
  @goal> =task1
  +imaginal>
    isa scratchpad
    position 1

)

(p retrieve-arithmetic-fact-unary-x
  =imaginal>
   isa   scratchpad
   x     nil
   position 1

  ?retrieval>
    state free

  =visual>
    isa  ritl-stimulus
    x  =x

  =goal>
    isa  operation
    operator =op
    argument2 =arg2
    type unary

==>
  =imaginal>
  =visual>
  +retrieval>
    isa arithmetic-fact
    operation =op
    arg1 =x
    arg2 =arg2
  +goal>
    isa do-execution
    step update-pad
)

(p update-scratchpad-x
  =goal>
  isa do-execution
  step update-pad
  
  =visual>
    isa  ritl-stimulus
    x  =x

  =retrieval>
    isa arithmetic-fact
    result =ans

  =imaginal>
    isa  scratchpad
    position 1
==>
  =visual>
  =imaginal>
    isa scratchpad
    x  =ans
  -goal>
  -retrieval>
)


(p calculate-y-unary
  "Just one operation for now"
  =goal>
    isa do-execution
    step setup
  
  =imaginal>
    isa          scratchpad
  - x            nil
    y            nil
    position    1

  =visual>
    isa  ritl-stimulus
    x       =x
    y       =y

  =retrieval>
    isa    ritl-instructions
    second   =task2

==>
  =visual>
  @goal> =task2
  =retrieval>
  =imaginal>
  position 2
)

(p retrieve-arithmetic-fact-unary-y
  =imaginal>
   isa   scratchpad
   y     nil
   position 2

  ?retrieval>
    state free

  =visual>
    isa  ritl-stimulus
    y  =y

  =goal>
    isa  operation
    operator =op
    argument2 =arg2
    type unary

==>
  =imaginal>
  =visual>
  +retrieval>
    isa arithmetic-fact
    operation =op
    arg1 =y
    arg2 =arg2
  +goal>
    isa do-execution
    step update-pad
)


(p update-scratchpad-y
  =imaginal>
    isa  scratchpad
    y    nil
    position 2

  =visual>
    isa  ritl-stimulus
    x  =x
    y  =y

  =retrieval>
    isa arithmetic-fact
    result =ans
  =goal>
    isa do-execution
    step update-pad
  
==>
  =visual>
  =imaginal>
    isa scratchpad
    y =ans

  -retrieval>
  -goal>
)


(p calculate-binary
  "Just one operation for now"
  =imaginal>
    isa          scratchpad
  - x            nil
  - y            nil
    position     2

  =retrieval>
    isa    ritl-instructions
    third   =task3

==>
  =retrieval>
  @goal> =task3
  =imaginal>
    position 3
)



(p retrieve-arithmetic-fact-binary
  =imaginal>
    isa scratchpad
    x  =x
    y  =y
    position  3

  =retrieval>
    isa    ritl-instructions
    third   =task3

  =goal>
    isa  operation
    operator =op
    type binary

==>
  =imaginal>
  +retrieval>
    isa arithmetic-fact
    operation =op
    arg1 =x
    arg2 =y
  +goal>
    isa do-execution
    step update-pad

)


(p update-scratchpad-binary
  =goal>
    isa do-execution
    step update-pad

  =retrieval>
    isa arithmetic-fact
    result =ans

  =imaginal>
    isa scratchpad
  - x   nil
  - y   nil
    result  nil

==>
  =imaginal>
    isa scratchpad
    result  =ans
    position    3

  -goal>
  -retrieval>
)



(p calculation-done
   "Detects when all the calculations are completed"
  ?retrieval>
    buffer       empty
    state        free
  ?imaginal>
    state        free
  =imaginal>
    isa          scratchpad
    result       =RES
    position     3
==>
 -goal>
 =imaginal>
    result      =RES
)


;;; --------------------------------------------------------------
;;; When it's done, just press a button to proceed
;;; --------------------------------------------------------------

(p go-through-inputs
   "When all calculations are completed, just presses a key"
  ?imaginal>
    state        free
  =imaginal>
    isa          scratchpad
  - result       nil
  ?manual>
    preparation  free
    execution    free
==>
  -visual>
  -visual-location>
  =imaginal>
  +manual>
    isa          press-key
    key          "2"
)



)