return(practiceInst)
}
session2Trials <- generateSession2Trials()
## MAKE DATA FROM SCRATCH
unary <- c("DOUBLE","TRIPLE","INCREMENT", "DECREMENT","THIRD", "HALF")
binary <- c("TIMES","DIVIDE","ADD", "SUBTRACT")
#Define functions
DECREMENT <- function(x) {x-1}
THIRD <- function(x) {x/3}
INCREMENT <- function(x) {x+1}
TRIPLE <- function(x) {x*3}
HALF <- function(x) {x/2}
DOUBLE <- function(x) {x*2}
SUBTRACT <- function(x, y) {x-y}
TIMES <- function(x,y) {x*y}
DIVIDE <- function(x,y) {x/y}
ADD <- function(x,y) {x+y}
generatePracticeTrials <- function(numPracticedCombinations = 2) {
practiceInst <- data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = sample(1:9,10,T), y = sample(1:9,10,T), probe = 0,  stringsAsFactors = F)
while (nrow(practiceInst)/10 != numPracticedCombinations) {
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
}
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session1Trials <- generatePracticeTrials()
generateSession2Trials <- function(numPracticedCombinations = 2, practiceInst = session1Trials) {
# WARNING: Chances are that filler items are identical to practiced trials
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = sample(unary,numPracticedCombinations*10,T), operatorTask2 = sample(unary,numPracticedCombinations*10,T), operatorTask3 = sample(binary,numPracticedCombinations*10,T),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session2Trials <- generateSession2Trials()
modelTrials <- rbind(session1Trials,session2Trials)
exportStimuli <- paste("((", modelTrials$operatorTask1, modelTrials$operatorTask2, modelTrials$operatorTask3, ")","(",modelTrials$x,modelTrials$y,")",modelTrials$probe,")")
write(exportStimuli,"trials",ncolumns=1)
duplicated.data.frame(exportStimuli)
duplicated.data.frame(modelTrials)
View(modelTrials)
## MAKE DATA FROM SCRATCH
unary <- c("DOUBLE","TRIPLE","INCREMENT", "DECREMENT","THIRD", "HALF")
binary <- c("TIMES","DIVIDE","ADD", "SUBTRACT")
#Define functions
DECREMENT <- function(x) {x-1}
THIRD <- function(x) {x/3}
INCREMENT <- function(x) {x+1}
TRIPLE <- function(x) {x*3}
HALF <- function(x) {x/2}
DOUBLE <- function(x) {x*2}
SUBTRACT <- function(x, y) {x-y}
TIMES <- function(x,y) {x*y}
DIVIDE <- function(x,y) {x/y}
ADD <- function(x,y) {x+y}
generatePracticeTrials <- function(numPracticedCombinations = 2) {
practiceInst <- data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = sample(1:9,10,T), y = sample(1:9,10,T), probe = 0,  stringsAsFactors = F)
while (nrow(practiceInst)/10 != numPracticedCombinations) {
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
}
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session1Trials <- generatePracticeTrials()
generateSession2Trials <- function(numPracticedCombinations = 2, practiceInst = session1Trials) {
# WARNING: Chances are that filler items are identical to practiced trials
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = sample(unary,numPracticedCombinations*10,T), operatorTask2 = sample(unary,numPracticedCombinations*10,T), operatorTask3 = sample(binary,numPracticedCombinations*10,T),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session2Trials <- generateSession2Trials()
## MAKE DATA FROM SCRATCH
unary <- c("DOUBLE","TRIPLE","INCREMENT", "DECREMENT","THIRD", "HALF")
binary <- c("TIMES","DIVIDE","ADD", "SUBTRACT")
#Define functions
DECREMENT <- function(x) {x-1}
THIRD <- function(x) {x/3}
INCREMENT <- function(x) {x+1}
TRIPLE <- function(x) {x*3}
HALF <- function(x) {x/2}
DOUBLE <- function(x) {x*2}
SUBTRACT <- function(x, y) {x-y}
TIMES <- function(x,y) {x*y}
DIVIDE <- function(x,y) {x/y}
ADD <- function(x,y) {x+y}
generatePracticeTrials <- function(numPracticedCombinations = 2) {
practiceInst <- data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = sample(1:9,10,T), y = sample(1:9,10,T), probe = 0,  stringsAsFactors = F)
while (nrow(practiceInst)/10 != numPracticedCombinations) {
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
}
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session1Trials <- generatePracticeTrials()
generateSession2Trials <- function(numPracticedCombinations = 2, practiceInst = session1Trials) {
# WARNING: Chances are that filler items are identical to practiced trials
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = sample(unary,numPracticedCombinations*10,T), operatorTask2 = sample(unary,numPracticedCombinations*10,T), operatorTask3 = sample(binary,numPracticedCombinations*10,T),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session2Trials <- generateSession2Trials()
## MAKE DATA FROM SCRATCH
unary <- c("DOUBLE","TRIPLE","INCREMENT", "DECREMENT","THIRD", "HALF")
binary <- c("TIMES","DIVIDE","ADD", "SUBTRACT")
#Define functions
DECREMENT <- function(x) {x-1}
THIRD <- function(x) {x/3}
INCREMENT <- function(x) {x+1}
TRIPLE <- function(x) {x*3}
HALF <- function(x) {x/2}
DOUBLE <- function(x) {x*2}
SUBTRACT <- function(x, y) {x-y}
TIMES <- function(x,y) {x*y}
DIVIDE <- function(x,y) {x/y}
ADD <- function(x,y) {x+y}
generatePracticeTrials <- function(numPracticedCombinations = 2) {
practiceInst <- data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = sample(1:9,10,T), y = sample(1:9,10,T), probe = 0,  stringsAsFactors = F)
while (nrow(practiceInst)/10 != numPracticedCombinations) {
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
}
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session1Trials <- generatePracticeTrials()
generateSession2Trials <- function(numPracticedCombinations = 2, practiceInst = session1Trials) {
# WARNING: Chances are that filler items are identical to practiced trials
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = sample(unary,numPracticedCombinations*10,T), operatorTask2 = sample(unary,numPracticedCombinations*10,T), operatorTask3 = sample(binary,numPracticedCombinations*10,T),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session2Trials <- generateSession2Trials()
modelTrials <- rbind(session1Trials,session2Trials)
exportStimuli <- paste("((", modelTrials$operatorTask1, modelTrials$operatorTask2, modelTrials$operatorTask3, ")","(",modelTrials$x,modelTrials$y,")",modelTrials$probe,")")
write(exportStimuli,"trials",ncolumns=1)
View(modelTrials)
duplicated.data.frame(modelTrials)
duplicated.data.frame(modelTrials[,1:5])
sum(duplicated.data.frame(modelTrials[,1:5]))
## MAKE DATA FROM SCRATCH
unary <- c("DOUBLE","TRIPLE","INCREMENT", "DECREMENT","THIRD", "HALF")
binary <- c("TIMES","DIVIDE","ADD", "SUBTRACT")
#Define functions
DECREMENT <- function(x) {x-1}
THIRD <- function(x) {x/3}
INCREMENT <- function(x) {x+1}
TRIPLE <- function(x) {x*3}
HALF <- function(x) {x/2}
DOUBLE <- function(x) {x*2}
SUBTRACT <- function(x, y) {x-y}
TIMES <- function(x,y) {x*y}
DIVIDE <- function(x,y) {x/y}
ADD <- function(x,y) {x+y}
generatePracticeTrials <- function(numPracticedCombinations = 2) {
practiceInst <- data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = sample(1:9,10,T), y = sample(1:9,10,T), probe = 0,  stringsAsFactors = F)
while (nrow(practiceInst)/10 != numPracticedCombinations) {
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
}
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session1Trials <- generatePracticeTrials()
generateSession2Trials <- function(numPracticedCombinations = 2, practiceInst = session1Trials) {
# WARNING: Chances are that filler items are identical to practiced trials
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = sample(unary,numPracticedCombinations*10,T), operatorTask2 = sample(unary,numPracticedCombinations*10,T), operatorTask3 = sample(binary,numPracticedCombinations*10,T),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session2Trials <- generateSession2Trials()
## MAKE DATA FROM SCRATCH
unary <- c("DOUBLE","TRIPLE","INCREMENT", "DECREMENT","THIRD", "HALF")
binary <- c("TIMES","DIVIDE","ADD", "SUBTRACT")
#Define functions
DECREMENT <- function(x) {x-1}
THIRD <- function(x) {x/3}
INCREMENT <- function(x) {x+1}
TRIPLE <- function(x) {x*3}
HALF <- function(x) {x/2}
DOUBLE <- function(x) {x*2}
SUBTRACT <- function(x, y) {x-y}
TIMES <- function(x,y) {x*y}
DIVIDE <- function(x,y) {x/y}
ADD <- function(x,y) {x+y}
generatePracticeTrials <- function(numPracticedCombinations = 2) {
practiceInst <- data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = sample(1:9,10,T), y = sample(1:9,10,T), probe = 0,  stringsAsFactors = F)
while (nrow(practiceInst)/10 != numPracticedCombinations) {
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = rep(sample(unary,1),10), operatorTask2 = rep(sample(unary,1),10), operatorTask3 = rep(sample(binary,1),10),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
}
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session1Trials <- generatePracticeTrials()
generateSession2Trials <- function(numPracticedCombinations = 2, practiceInst = session1Trials) {
# WARNING: Chances are that filler items are identical to practiced trials
practiceInst <- rbind(practiceInst,data.frame(
operatorTask1 = sample(unary,numPracticedCombinations*10,T), operatorTask2 = sample(unary,numPracticedCombinations*10,T), operatorTask3 = sample(binary,numPracticedCombinations*10,T),
x = 0, y = 0, probe = 0,  stringsAsFactors = F))
# Solve operations
for (i in 1:length(practiceInst$probe)) {
while((1>practiceInst$probe[i]) | (practiceInst$probe[i]>49)) {
practiceInst$x[i] <- sample(1:9,1)
practiceInst$y[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
while (!floor(tempX)) {
practiceInst$x[i] <- sample(1:9,1)
tempX <- match.fun(practiceInst$operatorTask1[i])(practiceInst$x[i])
}
while (!floor(tempY)) {
practiceInst$y[i] <- sample(1:9,1)
tempY <- match.fun(practiceInst$operatorTask2[i])(practiceInst$y[i])
}
practiceInst$probe[i] <- floor(match.fun(practiceInst$operatorTask3[i])(tempX,tempY))
}
}
# Add mistakes (-1 or +1) and randomize
mistakeRows <- sample(nrow(practiceInst),nrow(practiceInst)/2)
practiceInst$probe[mistakeRows] <- practiceInst$probe[mistakeRows]-1
practiceInst[practiceInst$probe == 0,"probe"] <- practiceInst[practiceInst$probe == 0,"probe"]+2 # If the probe becomes 0, make it 2
practiceInst <- practiceInst[sample(nrow(practiceInst),nrow(practiceInst)),]
return(practiceInst)
}
session2Trials <- generateSession2Trials()
modelTrials <- rbind(session1Trials,session2Trials)
exportStimuli <- paste("((", modelTrials$operatorTask1, modelTrials$operatorTask2, modelTrials$operatorTask3, ")","(",modelTrials$x,modelTrials$y,")",modelTrials$probe,")")
write(exportStimuli,"trials",ncolumns=1)
sum(duplicated.data.frame(modelTrials[,1:5]))
modelMonolingual <- read.csv("~/Documents/GitHub/ACTR_RITL/modelMonolingual5.txt")
session2Mono <- modelMonolingual[21:60,]
session2Mono$Practiced <- session2Mono$Rule == "(INCREMENT DOUBLE DIVIDE)" | session2Mono$Rule == "(TRIPLE INCREMENT ADD)"
aggregate(session2Mono$EncodingRT,list(session2Mono$Practiced),mean)
aggregate(session2Mono$ExecutionRT,list(session2Mono$Practiced),mean)
library(ggplot2)
session2Mono$lang <- "Monolingual"
modelMonolingual <- read.csv("~/Documents/GitHub/ACTR_RITL/modelMonolingual.txt")
session2Mono <- modelMonolingual[21:60,]
session2Mono$Practiced <- session2Mono$Rule == "(INCREMENT DOUBLE DIVIDE)" | session2Mono$Rule == "(TRIPLE INCREMENT ADD)"
aggregate(session2Mono$EncodingRT,list(session2Mono$Practiced),mean)
aggregate(session2Mono$ExecutionRT,list(session2Mono$Practiced),mean)
