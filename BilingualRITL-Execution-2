 (clear-all)

#+(or :clisp :sbcl :openmcl) (setf (logical-pathname-translations "INST")
				   `(("**;*.*" ,(namestring (merge-pathnames "**/*.*" *load-truename*)))))

(define-model execution

(chunk-type arithmetic-fact operation arg1 arg2 result)
(chunk-type ritl-stimulus x y)
(chunk-type ritl-instructions kind first second third)
(chunk-type operation argument1 operator argument2 trial)
(chunk-type do-execution step)

(load (translate-logical-pathname "INST:inst-arithmetic-facts.lisp"))

(add-dm (stimulus isa ritl-stimulus 
x 5 
y 6))

;;; Instructions in memory
(add-dm (double-1 isa operation argument1 x operator * argument2 2))
(add-dm (half-1 isa operation argument1 x operator / argument2 2))
(add-dm (add-1 isa operation argument1 x operator + argument2 y))
(add-dm (inst isa ritl-instructions kind ritl-instructions first double-1 second half-1 third add-1))
;;; Operations

(set-buffer-chunk 'visual 'stimulus)

(p prepare
  ?goal>
    state free
    buffer empty
    
  =visual>
    isa      ritl-stimulus
    x       =X
    y       =y

==>
  =visual>
  +goal>
    isa do-execution
    step setup

  +retrieval>
    isa ritl-instructions
    kind ritl-instructions
)

(p calculate-unary
  "Just one operation for now"
  =visual>
    isa  ritl-stimulus
    x    =x
    y    =y

  =retrieval>
    isa    ritl-instructions
    first   =task1

==>
  =retrieval>
  =visual>
  @imaginal> =task1

)

(p retrieve-arithmetic-fact

  =visual>
    isa  ritl-stimulus
    x  =x
    y  =y

  =imaginal>
    isa  operation
    operator =op
    argument2 =arg2

==>
  =imaginal>
  =visual>
  +retrieval>
    isa arithmetic-fact
    operation =op
    arg1 =x
    arg2 =arg2

)

(p update-scratchpad
  =visual>
    isa  ritl-stimulus
    x  =x
    y  =y

  =retrieval>
    isa arithmetic-fact
    result =ans

  =imaginal>
    isa  operation
    argument1 =arg1
==>
  =visual>
  =imaginal>
    isa  operation
    argument1 =ans

  -retrieval>
)


)