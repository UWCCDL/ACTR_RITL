;;;  -*- mode: LISP; Syntax: COMMON-LISP;  Base: 10 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Author      : Charlotte de Blecourt
;;;		: University of Groningen / University of Washington
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 
;;; Filename    : BilingualRITL-Encoding-1
;;; Version     : 0.1
;;; 
;;; Description : Model for mono-/bilingual performance on RITL task
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; 2017-12-11  : * File created. Based on inst-model-07.lisp by Stocco.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(clear-all)
(define-model inst

(sgp :trace-detail            medium 
     :show-focus              t 
     :esc                     t 
     :lf                      0.9 
     :mas                     1.6 
     :imaginal-activation     1.0 

     ;; Productions
     :epl                     t 
     :ul                      t
    :ult			      t

     ;; Perceptual params
     :auto-attend             t 
     :visual-finst-span       10.0)

(chunk-type arithmetic-fact operation arg1 arg2 result)
(chunk-type operation task type operator arg1 arg2 position)
(chunk-type mapping command operation type argument)   
(chunk-type scratchpad x y result position state task)
(chunk-type serial position task)

(add-dm (x isa chunk) (y isa chunk) (* isa chunk) (+ isa chunk)
	(/ isa chunk) (unary isa chunk) (binary isa chunk))

(add-dm (a isa mapping 
	   command   TIMES
	   operation *
	   type      binary
	   argument  nil)
	(b isa       mapping
	   command   DUBBLE
	   operation *
	   type      unary
	   argument  2)
	(c isa       mapping
	   command   TRIPLE
	   operation *
	   type      unary
	   argument  3)
	(d isa mapping
	   command   DIVIDE
	   operation /
	   type      binary
	   argument  nil)
	(e isa       mapping
	   command   THIRD
	   operation /
	   type      unary
	   argument  3)
	(f isa       mapping
	   command   HALF
	   operation /
	   type      unary
	   argument  2)
	(g isa       mapping
	   command   INCREASE
	   operation +
	   type      unary
	   argument  1)
	(h isa mapping 
	   command   ADD
	   operation +
	   type      binary
	   argument  nil)
	(i isa mapping
	   command   SUBSTRACT
	   operation -
	   type      binary
	   argument  nil)
	(j isa       mapping
	   command   DECREASE
	   operation -
	   type      unary
	   argument  1))


;;; Visual states
;;; (NOTE should be added to the device to keep model code clean)
;;;
(add-dm (screen isa chunk)
	(instructions isa chunk)
	(inputs isa chunk)
	(probe isa chunk)
	(probe-responded isa chunk)
	(fixation isa chunk)
	(fixation1 isa chunk)
	(fixation2 isa chunk)
	(blank isa chunk)
	(feedback isa chunk)
	(operation isa chunk)
	(variable isa chunk))

(load (translate-logical-pathname "INST:inst-arithmetic-facts.lisp"))

;;; -------------------------------------------------------------- ;;;
;;; BASIC VISUAL ACTIONS
;;; -------------------------------------------------------------- ;;;
;;; Just encodes the screen when the model iss not looking at 
;;; anything in particular.
;;; -------------------------------------------------------------- ;;;

;; This production should never fire --- it's here to make the 
;; model work when code is changed and bugs are introduced.
;;
#|
(p look-at-the-screen
   "Looks at the screen if visual pathways are empty"
  ?visual-location>
    buffer       empty
    state        free
  ?visual>
    state        free
    buffer       empty
  ?manual>
    preparation  free
    execution    free
==>
  +visual-location>
    isa          visual-location
    kind         screen
)
|#

(p encode-the-screen
   "Encodes the screen if it's in visual-location"
  =visual-location>
    isa          visual-location
    kind         screen
  ?visual>
    state        free
    buffer       empty
==>
  +visual>
    isa          move-attention
    screen-pos  =visual-location
)

;;; -------------------------------------------------------------- ;;;
;;; INSTRUCTION PHASE
;;; -------------------------------------------------------------- ;;;
;;; During the instruction phase the model reads the screen and 
;;; encodes the necessary operations that are to be performed in
;;; the next phase.
;;; -------------------------------------------------------------- ;;;

(p look-at-instructions 
   "When instructions are detected, they are first encoded as a whole"
  ?imaginal>
    state        free
    buffer       empty
  =visual>
    isa          visual-object
    status       screen
    value        instructions
==>
  +visual-location>
    isa          visual-location
    kind         instructions
)


(p prepare-for-encoding 
   "Prepares to encode operations when the instructions are on"
  ?imaginal>
    state        free
    buffer       empty
  =visual>
    isa          visual-object
    status       instructions
    value       =TASK
==>
  +imaginal>
    isa          serial
    position     1
    task        =TASK
  +visual-location>
    isa          visual-location
    kind         operation
    screen-x     highest
    :attended    nil
)


(p find-mapping
   "Finds a mapping between a letter and the corresponding operation"
  ?retrieval>
    state        free
    buffer       empty
  ?goal>
    state        free
    buffer       empty
  =imaginal>
    isa          serial
  =visual>
    isa          visual-object
    status       operation
    value       =LETTER
==>
  =imaginal>
  =visual>
  +retrieval>
    isa          mapping
    command      =LETTER
)


(p encode-unary-operation
   "Encodes a unary operation"
  =retrieval>
    isa          mapping
    operation   =OP
    argument    =ARG
    type         unary
  =imaginal>
    isa          serial
    position    =POS
    task        =TASK
  =visual>
    isa          visual-object
    status       operation
==>
  =imaginal>
  =visual>
  +goal>
    isa          operation
    type         unary
    task        =TASK
    operator    =OP
    arg2        =ARG
    position    =POS
)

(p find-variable-for-unary-operation
   "Determines which variable (X or Y) an operation applies to"
  ?visual>
    state        free
  =visual>
    isa          visual-object
    status       operation
    value       =LETTER
  =goal>
    isa          operation
    arg1         nil
  - arg2         nil
==>
  +visual-location>
    isa          visual-location
    kind         variable
  > screen-x     current
    screen-x     lowest
)


(p encode-variable-for-unary-operation
   "Encodes which variable an operation applies to"
  ?visual>
    state        free
  =visual>
    isa          visual-object
    status       variable
    value       =VARIABLE
  =goal>
    isa          operation
    arg1         nil
  - arg2         nil
==>
  =visual>
  =goal>
    arg1        =VARIABLE
)


;;; --------------------------------------------------------------
;;; In case of binary operations, one needs to look at both
;;; variables (to make sure to get them in order).
;;; --------------------------------------------------------------  

(p encode-binary-operation
  =retrieval>
    isa          mapping
    operation   =OP
    type         binary
  =imaginal>
    isa          serial
    position    =POS
    task        =TASK
  =visual>
    isa          visual-object
    status       operation
==>
  =imaginal>
  =visual>
  +goal>
    isa          operation
    type         binary
    operator    =OP
    position    =POS
    task        =TASK

    ;; One could possibly set X and Y right now 
    ;; since there are no Y/X trials.

    ;arg1 x
    ;arg2 y
)


(p find-first-variable-for-binary-operation
   "Finds the first variable for a bin operation (A or B)"
  ?visual>
    state        free
  =visual>
    isa          visual-object
    status       operation
    value       =LETTER
  =goal>
    isa          operation
    arg1         nil
    arg2         nil
==>
  +visual-location>
    isa          visual-location
    kind         variable
  > screen-x     current
    screen-x     lowest
)


(p encode-first-variable-for-binary-operation
   "Stores the first variable as ARG1 in the goal buffer"
  ?visual>
    state        free
  =visual>
    isa          visual-object
    status       variable
    value       =VARIABLE
  =goal>
    isa          operation
    arg1         nil
    arg2         nil
==>
  =goal>
    arg1        =VARIABLE
)


(p find-second-variable-for-binary-operation
   "Finds the second variable for a binayr operation (A or B)"
  ?visual>
    state        free
  ?retrieval>
    state        free
    buffer       empty
  =goal>
    isa          operation
  - arg1         nil
    arg2         nil
==>
  +visual-location>
    isa          visual-location
    kind         variable
  > screen-x     current
    screen-x     lowest
)


(p encode-second-variable-for-binary-operation
   "Stores the second variable (x or y) as ARG2 in the goal buffer"
  ?visual>
    state        free
  =visual>
    isa          visual-object
    status       variable
    value       =VARIABLE
  =goal>
    isa          operation
  - arg1         nil
    arg2         nil
==>
  =visual>
  =goal>
    arg2        =VARIABLE
)


;;; --------------------------------------------------------------
;;; Updates the position and proceeds.
;;; --------------------------------------------------------------

(p update-position
   "When an operation has been created, it is saved in memory and 
the model prepares for the next position in the series"
  ?imaginal>
    state        free
  =imaginal>
    isa          serial
  - position     3
  =goal>
    isa          operation
  - arg1         nil
  - arg2         nil
==>
  -goal>
  =imaginal>
  +imaginal-action>
    isa          generic-action
    action       inst-update-position
)


(p find-operation
   "Finds the next unattended operation on the screen (from right 
to left)"
  ?imaginal>
    state        free
  ?goal>
    state        free
    buffer       empty
  =imaginal>
    isa          serial
  =visual>
    isa          visual-object
    status       variable
;  - status       operation
;  - status       screen
==>
  =imaginal>
  +visual-location>
    isa          visual-location
    kind         operation
    screen-x     highest
    :attended    nil
)
  

;;; --------------------------------------------------------------
;;; Press a key when done
;;; --------------------------------------------------------------

(p go-through-instructions
   "Presses a key after instructions have been encoded"
  ?imaginal>
    state        free
  =imaginal>
    isa          serial
    position     3
  =goal>
    isa          operation
  - arg1         nil
  - arg2         nil
  ?manual>
    preparation  free
    execution    free
==>
  -goal>
  -visual>
  -visual-location>
  =imaginal>
  +manual>
    isa          press-key
    key          "2"
)
)

